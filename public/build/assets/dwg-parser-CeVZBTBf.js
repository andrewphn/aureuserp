var C=(f,s)=>()=>(s||f((s={exports:{}}).exports,s),s.exports);var N=C((T,h)=>{const w={LINE:"LINE",POLYLINE:"POLYLINE",LWPOLYLINE:"LWPOLYLINE",CIRCLE:"CIRCLE",ARC:"ARC",ELLIPSE:"ELLIPSE",SPLINE:"SPLINE",TEXT:"TEXT",MTEXT:"MTEXT",DIMENSION:"DIMENSION",INSERT:"INSERT",BLOCK:"BLOCK",HATCH:"HATCH",SOLID:"SOLID",POINT:"POINT",FACE3D:"3DFACE",VIEWPORT:"VIEWPORT"};class L{constructor(){this.entities=[],this.layers={},this.blocks={},this.header={},this.bounds={minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}parse(s){const a=s.split(/\r?\n/),e=this._parsePairs(a);let r=null,t=0;for(;t<e.length;){const[o,i]=e[t];if(o===0&&i==="SECTION")t++,e[t]&&e[t][0]===2&&(r=e[t][1]);else if(o===0&&i==="ENDSEC")r=null;else if(r==="HEADER"){t=this._parseHeader(e,t);continue}else if(r==="TABLES"){t=this._parseTables(e,t);continue}else if(r==="BLOCKS"){t=this._parseBlocks(e,t);continue}else if(r==="ENTITIES"){t=this._parseEntities(e,t);continue}t++}return{header:this.header,layers:this.layers,blocks:this.blocks,entities:this.entities,bounds:this.bounds,stats:{entityCount:this.entities.length,layerCount:Object.keys(this.layers).length,blockCount:Object.keys(this.blocks).length}}}_parsePairs(s){var e;const a=[];for(let r=0;r<s.length-1;r+=2){const t=parseInt(s[r].trim(),10),o=((e=s[r+1])==null?void 0:e.trim())||"";isNaN(t)||a.push([t,o])}return a}_parseHeader(s,a){let e=a;for(;e<s.length;){const[r,t]=s[e];if(r===0&&(t==="ENDSEC"||t==="SECTION"))return e;if(r===9){const o=t,i=[];for(e++;e<s.length&&s[e][0]!==9&&s[e][0]!==0;)i.push({code:s[e][0],value:s[e][1]}),e++;this.header[o]=i.length===1?i[0].value:i;continue}e++}return e}_parseTables(s,a){let e=a,r=null;for(;e<s.length;){const[t,o]=s[e];if(t===0&&o==="ENDSEC")return e;if(t===0&&o==="TABLE")e++,s[e]&&s[e][0]===2&&(r=s[e][1]);else if(t===0&&o==="LAYER"&&r==="LAYER"){const i=this._parseLayer(s,e);i.name&&(this.layers[i.name]=i),e=i.endIndex;continue}e++}return e}_parseLayer(s,a){const e={name:"",color:7,frozen:!1,locked:!1};let r=a+1;for(;r<s.length;){const[t,o]=s[r];if(t===0)break;switch(t){case 2:e.name=o;break;case 62:e.color=parseInt(o,10);break;case 70:const i=parseInt(o,10);e.frozen=(i&1)!==0,e.locked=(i&4)!==0;break}r++}return e.endIndex=r,e}_parseBlocks(s,a){let e=a,r=null;for(;e<s.length;){const[t,o]=s[e];if(t===0&&o==="ENDSEC")return e;t===0&&o==="BLOCK"?r={name:"",entities:[],basePoint:{x:0,y:0}}:t===0&&o==="ENDBLK"?(r&&r.name&&(this.blocks[r.name]=r),r=null):r&&(t===2?r.name=o:t===10?r.basePoint.x=parseFloat(o):t===20&&(r.basePoint.y=parseFloat(o))),e++}return e}_parseEntities(s,a){let e=a;for(;e<s.length;){const[r,t]=s[e];if(r===0&&t==="ENDSEC")return e;if(r===0&&w[t]){const o=this._parseEntity(s,e,t);o&&(this.entities.push(o),this._updateBounds(o)),e=o?o.endIndex:e+1;continue}e++}return e}_parseEntity(s,a,e){const r={type:e,layer:"0",color:null,handle:null};let t=a+1;for(;t<s.length;){const[o,i]=s[t];if(o===0)break;switch(o){case 5:r.handle=i;break;case 8:r.layer=i;break;case 62:r.color=parseInt(i,10);break;case 6:r.lineType=i;break}this._parseEntityProperty(r,e,o,i),t++}return r.endIndex=t,r}_parseEntityProperty(s,a,e,r){switch(a){case"LINE":e===10?s.x1=parseFloat(r):e===20?s.y1=parseFloat(r):e===11?s.x2=parseFloat(r):e===21&&(s.y2=parseFloat(r));break;case"CIRCLE":e===10?s.x=parseFloat(r):e===20?s.y=parseFloat(r):e===40&&(s.radius=parseFloat(r));break;case"ARC":e===10?s.x=parseFloat(r):e===20?s.y=parseFloat(r):e===40?s.radius=parseFloat(r):e===50?s.startAngle=parseFloat(r):e===51&&(s.endAngle=parseFloat(r));break;case"LWPOLYLINE":case"POLYLINE":s.vertices||(s.vertices=[]),e===10?s.vertices.push({x:parseFloat(r),y:0,bulge:0}):e===20&&s.vertices.length>0?s.vertices[s.vertices.length-1].y=parseFloat(r):e===42&&s.vertices.length>0?s.vertices[s.vertices.length-1].bulge=parseFloat(r):e===70&&(s.closed=(parseInt(r,10)&1)!==0);break;case"TEXT":case"MTEXT":e===1?s.text=r:e===10?s.x=parseFloat(r):e===20?s.y=parseFloat(r):e===40?s.height=parseFloat(r):e===50?s.rotation=parseFloat(r):e===7&&(s.style=r);break;case"INSERT":e===2?s.blockName=r:e===10?s.x=parseFloat(r):e===20?s.y=parseFloat(r):e===41?s.scaleX=parseFloat(r):e===42?s.scaleY=parseFloat(r):e===50&&(s.rotation=parseFloat(r));break;case"ELLIPSE":e===10?s.x=parseFloat(r):e===20?s.y=parseFloat(r):e===11?s.majorAxisX=parseFloat(r):e===21?s.majorAxisY=parseFloat(r):e===40?s.ratio=parseFloat(r):e===41?s.startAngle=parseFloat(r):e===42&&(s.endAngle=parseFloat(r));break;case"DIMENSION":e===10?s.x=parseFloat(r):e===20?s.y=parseFloat(r):e===1?s.text=r:e===70&&(s.dimensionType=parseInt(r,10));break;case"SPLINE":s.controlPoints||(s.controlPoints=[]),s.fitPoints||(s.fitPoints=[]),e===10?s.controlPoints.push({x:parseFloat(r),y:0}):e===20&&s.controlPoints.length>0?s.controlPoints[s.controlPoints.length-1].y=parseFloat(r):e===11?s.fitPoints.push({x:parseFloat(r),y:0}):e===21&&s.fitPoints.length>0?s.fitPoints[s.fitPoints.length-1].y=parseFloat(r):e===71&&(s.degree=parseInt(r,10));break;case"POINT":e===10?s.x=parseFloat(r):e===20&&(s.y=parseFloat(r));break;case"SOLID":case"3DFACE":s.points||(s.points=[{},{},{},{}]),e===10?s.points[0].x=parseFloat(r):e===20?s.points[0].y=parseFloat(r):e===11?s.points[1].x=parseFloat(r):e===21?s.points[1].y=parseFloat(r):e===12?s.points[2].x=parseFloat(r):e===22?s.points[2].y=parseFloat(r):e===13?s.points[3].x=parseFloat(r):e===23&&(s.points[3].y=parseFloat(r));break}}_updateBounds(s){const a=this._getEntityPoints(s);for(const e of a)e.x!==void 0&&(this.bounds.minX=Math.min(this.bounds.minX,e.x),this.bounds.maxX=Math.max(this.bounds.maxX,e.x)),e.y!==void 0&&(this.bounds.minY=Math.min(this.bounds.minY,e.y),this.bounds.maxY=Math.max(this.bounds.maxY,e.y))}_getEntityPoints(s){const a=[];switch(s.type){case"LINE":a.push({x:s.x1,y:s.y1}),a.push({x:s.x2,y:s.y2});break;case"CIRCLE":case"ARC":a.push({x:s.x-s.radius,y:s.y-s.radius}),a.push({x:s.x+s.radius,y:s.y+s.radius});break;case"LWPOLYLINE":case"POLYLINE":s.vertices&&a.push(...s.vertices);break;default:s.x!==void 0&&s.y!==void 0&&a.push({x:s.x,y:s.y})}return a}}class m{constructor(s={}){this.options={wasmPath:s.wasmPath||"/js/libredwg.wasm",enableDwg:s.enableDwg??!0,...s},this.dxfParser=new L,this.wasmModule=null,this.wasmLoaded=!1}async parse(s,a=""){if(a.toLowerCase().split(".").pop(),s instanceof File){a=s.name;const e=await this._readFile(s);return this._parseContent(e,a)}else if(s instanceof Blob){const e=await this._readBlob(s);return this._parseContent(e,a)}else if(typeof s=="string")return this._parseContent(s,a);throw new Error("Invalid input type. Expected File, Blob, or string.")}async _parseContent(s,a){return a.toLowerCase().split(".").pop()==="dwg"||this._isDwgBinary(s)?this._parseDwg(s):this._parseDxf(s)}_parseDxf(s){const a=typeof s=="string"?s:new TextDecoder().decode(s);return{format:"DXF",...this.dxfParser.parse(a)}}async _parseDwg(s){if(!this.options.enableDwg)throw new Error("DWG parsing is disabled. Enable it in options or use server-side parsing.");return this.wasmLoaded||await this._loadWasmModule(),this.wasmModule?this._parseWithWasm(s):{format:"DWG",error:"DWG WebAssembly module not available",suggestion:"Use server-side parsing via /api/dwg/parse endpoint",serverParseEndpoint:"/api/dwg/parse"}}async _loadWasmModule(){try{if(typeof window<"u"&&window.LibreDwg){this.wasmModule=window.LibreDwg,this.wasmLoaded=!0;return}const s=await fetch(this.options.wasmPath);if(s.ok){const a=await WebAssembly.instantiateStreaming(s);this.wasmModule=a.instance.exports,this.wasmLoaded=!0}}catch(s){console.warn("Could not load DWG WebAssembly module:",s.message),this.wasmLoaded=!0}}async _parseWithWasm(s){return{format:"DWG",error:"Native DWG parsing not yet implemented",suggestion:"Convert DWG to DXF using AutoCAD or use server-side parsing"}}_isDwgBinary(s){if(typeof s=="string")return s.startsWith("AC10")||s.startsWith("AC21");if(s instanceof ArrayBuffer||s instanceof Uint8Array){const a=s instanceof ArrayBuffer?new Uint8Array(s):s;return a[0]===65&&a[1]===67}return!1}async _readFile(s){return new Promise((a,e)=>{const r=new FileReader,t=s.name.toLowerCase().split(".").pop();r.onload=()=>a(r.result),r.onerror=()=>e(r.error),t==="dwg"?r.readAsArrayBuffer(s):r.readAsText(s)})}async _readBlob(s){return s.text()}toSVG(s,a={}){const{width:e=800,height:r=600,padding:t=20,strokeColor:o="#000000",strokeWidth:i=1,backgroundColor:n="#ffffff",layerColors:l={}}=a,{bounds:c,entities:u}=s,x=c.maxX-c.minX,d=c.maxY-c.minY,g=e-t*2,I=r-t*2,b=Math.min(g/x,I/d),P=(p,E)=>({x:t+(p-c.minX)*b,y:r-t-(E-c.minY)*b}),F=u.map(p=>{const E=l[p.layer]||o;return this._entityToSVG(p,P,{color:E,strokeWidth:i})}).filter(Boolean);return`<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" 
     width="${e}" height="${r}" 
     viewBox="0 0 ${e} ${r}"
     style="background-color: ${n}">
  <g stroke="${o}" stroke-width="${i}" fill="none">
    ${F.join(`
    `)}
  </g>
</svg>`}_entityToSVG(s,a,e){const{color:r,strokeWidth:t}=e;switch(s.type){case"LINE":{const o=a(s.x1,s.y1),i=a(s.x2,s.y2);return`<line x1="${o.x}" y1="${o.y}" x2="${i.x}" y2="${i.y}" stroke="${r}"/>`}case"CIRCLE":{const o=a(s.x,s.y),i=s.radius*Math.abs(a(1,0).x-a(0,0).x);return`<circle cx="${o.x}" cy="${o.y}" r="${i}" stroke="${r}"/>`}case"ARC":{const o=a(s.x,s.y),i=s.radius*Math.abs(a(1,0).x-a(0,0).x),n=s.startAngle*Math.PI/180,l=s.endAngle*Math.PI/180,c=o.x+i*Math.cos(n),u=o.y-i*Math.sin(n),x=o.x+i*Math.cos(l),d=o.y-i*Math.sin(l),g=Math.abs(l-n)>Math.PI?1:0;return`<path d="M ${c} ${u} A ${i} ${i} 0 ${g} 0 ${x} ${d}" stroke="${r}"/>`}case"LWPOLYLINE":case"POLYLINE":{if(!s.vertices||s.vertices.length<2)return null;const o=s.vertices.map(n=>{const l=a(n.x,n.y);return`${l.x},${l.y}`}).join(" ");return`<${s.closed?"polygon":"polyline"} points="${o}" stroke="${r}"/>`}case"TEXT":case"MTEXT":{const o=a(s.x,s.y),i=(s.height||1)*Math.abs(a(1,0).x-a(0,0).x),n=s.rotation||0;return`<text x="${o.x}" y="${o.y}" font-size="${i}" 
                        transform="rotate(${-n} ${o.x} ${o.y})" 
                        fill="${r}" stroke="none">${this._escapeXml(s.text||"")}</text>`}case"ELLIPSE":{const o=a(s.x,s.y),i=Math.abs(a(1,0).x-a(0,0).x),n=Math.sqrt(s.majorAxisX**2+s.majorAxisY**2)*i,l=n*s.ratio,c=Math.atan2(s.majorAxisY,s.majorAxisX)*180/Math.PI;return`<ellipse cx="${o.x}" cy="${o.y}" 
                        rx="${n}" ry="${l}" 
                        transform="rotate(${-c} ${o.x} ${o.y})" 
                        stroke="${r}"/>`}case"POINT":{const o=a(s.x,s.y);return`<circle cx="${o.x}" cy="${o.y}" r="2" fill="${r}"/>`}default:return null}}_escapeXml(s){return s.replace(/[<>&'"]/g,a=>({"<":"&lt;",">":"&gt;","&":"&amp;","'":"&apos;",'"':"&quot;"})[a])}toGeoJSON(s){return{type:"FeatureCollection",features:s.entities.map(e=>{const r=this._entityToGeoJSONGeometry(e);return r?{type:"Feature",properties:{layer:e.layer,color:e.color,type:e.type,handle:e.handle},geometry:r}:null}).filter(Boolean),crs:{type:"name",properties:{name:"urn:ogc:def:crs:OGC:1.3:CRS84"}}}}_entityToGeoJSONGeometry(s){switch(s.type){case"POINT":return{type:"Point",coordinates:[s.x,s.y]};case"LINE":return{type:"LineString",coordinates:[[s.x1,s.y1],[s.x2,s.y2]]};case"LWPOLYLINE":case"POLYLINE":if(!s.vertices||s.vertices.length<2)return null;const a=s.vertices.map(r=>[r.x,r.y]);return s.closed?(a.push(a[0]),{type:"Polygon",coordinates:[a]}):{type:"LineString",coordinates:a};case"CIRCLE":const e=[];for(let r=0;r<=36;r++){const t=r*10*Math.PI/180;e.push([s.x+s.radius*Math.cos(t),s.y+s.radius*Math.sin(t)])}return{type:"Polygon",coordinates:[e]};default:return null}}getLayerStats(s){var e;const a={};for(const r of s.entities){const t=r.layer||"0";a[t]||(a[t]={name:t,entityCount:0,types:{},color:(e=s.layers[t])==null?void 0:e.color}),a[t].entityCount++,a[t].types[r.type]=(a[t].types[r.type]||0)+1}return a}filterByLayers(s,a){const e=new Set(a.map(r=>r.toLowerCase()));return{...s,entities:s.entities.filter(r=>e.has((r.layer||"0").toLowerCase()))}}filterByTypes(s,a){const e=new Set(a.map(r=>r.toUpperCase()));return{...s,entities:s.entities.filter(r=>e.has(r.type))}}}typeof h<"u"&&h.exports?h.exports={DwgParser:m,DxfParser:L,EntityTypes:w}:typeof window<"u"&&(window.DwgParser=m,window.DxfParser=L,window.EntityTypes=w)});export default N();
